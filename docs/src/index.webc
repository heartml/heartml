---
layout: "default.webc"
---

<h1 style="text-align:center">Heartml: Postmodern HTML. üç≠<br/>Web components with the hots for declarative markup. üòª</h1>

<template webc:type="11ty" 11ty:type="md">

<abbr title="Hyper Expressive and Reactive Template Modules Library">Heartml</abbr> is the web‚Äôs most **versatile** new component format, centered around present **open standards** and running in the direction of future ones.

You can define Heartml components entirely in JavaScript, in declarative Single-File Component **HTML module** files, or simply embedded directly in any HTML page.

Write **split components** (all markup is renderer server-side, then upgraded with client-side behavior), **hybrid components** (markup from server, but shipping with a template so new components can be initialized on the client), or even **client-side only** components.

‚òÖ **Callee** can't wait to explain how everything works! <img src="/images/Callee - cutout.png" alt="Callee" style="width:100px; margin-inline-start: 0.5em; vertical-align: -1em" /> {style="text-align:right"}

## Features! So Many Features!

### Every Component Everywhere All at Once

* Server-agnostic: Ruby renderer today, JavaScript coming soon
* But you can even integrate with other server renderers like WebC!
* Use Heartml all by itself or alongside other web components built with Lit, etc.!
* Heartml works everywhere! Use Heartml in all kinds of stacks, from WordPress to Ruby on Rails to Eleventy

### Choose Your Flavor

* Many features work in light DOM and in shadow DOM, often simultaneously
* Signals provides for coordinated client state across components
* SFC Heartml modules can be loaded directly in buildless environments or bundled via esbuild

### Extensible by Design

* 98% of functionality is located in plugins, rather than base class (and you could even write your own base class if you really want to!)
* Write your own plugins! ‚ÄúComposable‚Äù behaviors components can opt-into via either JavaScript or declarative HTML!
* Package provides unbundled ESM, or install pre-bundled/minified CDN-friendly version
* Tiny ~5KB compressed size

‚òÖ **Callee** has a few demos she's like to show you! <img src="/images/Callee - cutout.png" alt="Callee" style="width:100px; margin-inline-start: 0.5em; vertical-align: -1em" /> {style="text-align:right"}

</template>

<playground-ide>
  <script webc:keep type="sample/html" filename="index.html">

<head>
  <script type="module" src="./component.js">&lt;/script>
  <link rel="stylesheet" href="defaults.css" />
</head>
<body>
  <my-component count="10">
    <button host-event="click#decrement">Dec -</button>
    Counter:
    <span host-effect="@textContent = .count">0</span>
    <button host-event="click#increment">Inc +</button>
  </my-component>
</body>

  </script>

  <script webc:keep type="sample/js" filename="component.js">

import { HeartElement } from "heartml"

class MyComponent extends HeartElement {
  static properties = {
    count: {}
  }

  static declarativeEffects = { light: true }

  static declarativeEvents = ["click"]

  static {
    this.define("my-component")
  }

  start() {
    this.count = 1
  }

  increment() {
    this.count++
  }

  decrement() {
    this.count--
  }
}

  </script>
</playground-ide>

<playground-ide>
  <script webc:keep type="sample/html" filename="index.html">

<head>
  <script type="module" src="./component.js">&lt;/script>
  <link rel="stylesheet" href="global.css" />
</head>
<body>
  <name-change name="Jared White">
    <p host-effect="@textContent = .name">x</p>
    
    <label>Rename:
    <input type="text" host-effect="@value = .name" host-event="input#changeName" />
    </label>
  </name-change>
</body>

  </script>

  <script webc:keep type="sample/js" filename="component.js">

import { HeartElement } from "heartml"

class MyComponent extends HeartElement {
  static properties = {
    name: {}
  }

  static declarativeEffects = { light: true }

  static declarativeEvents = ["input"]

  static {
    this.define("name-change")
  }

  start() {
    this.name = ""
  }

  changeName(event) {
    this.name = event.target.value
  }
}

  </script>

  <script webc:keep type="sample/css" filename="global.css">

@import "defaults.css";

p {
  font-size: 150%;
  font-weight: bold;
}

  </script>
</playground-ide>


<playground-ide>
  <script webc:keep type="sample/html" filename="index.html">

<head>
  <script src="https://cdn.jsdelivr.net/npm/heartml@0.13.0">&lt;/script>
  <link rel="stylesheet" href="global.css" />
</head>
<body>
  <name-change>
    <p host-effect="@textContent = .name">x</p>
    
    <label>Phone number:
    <input type="text" host-effect="@value = .name" host-event="input#changeName" />
    </label>
  </name-change>

  <heart-ml tag="name-change"
    properties='{ "name": {} }'
    declarative-effects='{ "light": true }'
    declarative-events='["input"]'
  >
    <script type="module">
      class NameChange extends HeartElement {
        start() {
          this.name = ""
        }
      
        changeName(event) {
          this.name = event.target.value.replace(/[a-zA-Z]*/g, "")
        }
      }
      NameChange.hoist()
    &lt;/script>
  </heart-ml>
</body>

  </script>

  <script webc:keep type="sample/css" filename="global.css">

@import "defaults.css";

p {
  font-size: 150%;
  font-weight: bold;
}

  </script>
</playground-ide>


<template webc:type="11ty" 11ty:type="md">

### Heartml Module Files (SFCs)

When you're ready to write a Single-File Component that's not simply JavaScript, here comes `.heartml`.

</template>

<playground-ide>
  <script webc:keep type="sample/html" filename="index.html">

<head>
  <script src="https://cdn.jsdelivr.net/npm/heartml@0.13.0">&lt;/script>
  <link rel="stylesheet" href="global.css" />
</head>
<body>
  <my-counter count="1"></my-counter>
  <heart-module src="counter.heartml"></heart-module>
</body>

  </script>

  <script webc:keep type="sample/html" filename="counter.heartml">

<script type="module">
  class Counter extends HeartElement {
    static template = import.meta.document
    static properties = { count: {} }
    static declarativeEffects = { shadow: true }
    static declarativeEvents = ["click"]

    start() { this.count = 0 }
    increment(event) { this.count++ }
    decrement(event) { this.count-- }
  }
  Counter.define("my-counter")
&lt;/script>

<template>
  <button host-event="click#decrement">-</button>
  <strong host-effect="@textContent=.count" style="display: inline-block; width: 4rem">0</strong>
  <button host-event="click#increment">+</button>
</template>

<style>
  :host { display: block; text-align: center; font-size: 200%; }
  button { font-size: inherit; }
</style>

  </script>

  <script webc:keep type="sample/css" filename="global.css">

@import "defaults.css";

p {
  font-size: 150%;
  font-weight: bold;
}

  </script>
</playground-ide>

<my-component @prop="neeet"></my-component>